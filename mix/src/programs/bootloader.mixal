IN 16,16 // Read second card into memory 16  .... " 0 06"
JBUS 2, 16 // wait for card to be read " A 04"
LD1 0 [0:0] // write zero in I1, I1 contains buffer offset "    I"
IN 32,16 // Read card into memory address 32 " 2 06"
JBUS 4, 16 // wait for card to be read " C 04"
LDA 33 // get the second byte from the card into A " 3 EH"
SLA 1 // push the 1st bit out (the number of words) " A  F"
SRAX 6 // AX contains the starting location " F CF"
NUM 30 // A is now a number - use 30 elsewhere in program (NUM ignores it) " 0  E"
STA 48 // write starting location to 48 " = EU"
LDA 33[1:1] // read number of words into A " 3 IH"
SUB 8[0:2] // subtract 30 (from line 8) to make A into a number " H BB"
STA 49 // write number of words into 49 " $ EU"
LD3 48 // I2 = write location " = EJ"
JAZ 0,3 // jump to location on transfer card "  CF."
LDA 35,1 (5:5) // read last character " 5A-H"
SUB 24 (0:2) // subtract 22 ( the value 20 is in the memory location 24 (line 25) ) " U BB"
STA 0,3(0:0) // just store a sign (if this was positive the number was 30,31,...,39 and not overpunched, if it was overpunched, it was 10,11,...19, and subtracting 22 makes it negative) "  C U"
LDA 48 // Load write_loc to A " = EH"
ADD 6[0:2] // write_loc = write_loc + 1 " F BA"
STA 48 // 48 = write_loc + 1 " = EU"
LDA 34,1 // load into A buffer (+ offset) " 4AEH"
LDX 35,1 // load into X buffer (+ offset) " 5AEH"
MOVE 0,0(2) // Side effect of Move is I1 += 2 . This is here to move the NUM later "   BG"
NUM 22 // convert to number in A ( 22 used earlier) " S  E"
STA 0,3[1:5] // store A into indirect I2 (which should be the write location), but just magnitude (sign was written earlier) "  CLU"
LDA 49 // get number of words into 49 " $ EH"
SUB 6[0:2] // subtract 1 from A " F BB"
STA 49 // write num words - 1 into 49 " $ EU"
JAP 13 // jump back to loading I3 with write location " L B."
JMP 2 // go to reading the next card " B  9"
