 ORIG 100
START ENT1 12        * N for FAREY series
     ENTX STOP
     JMP  ENTER
     ENT2 0        * BUFFER
     ENTA 0        * numerator
     ENTX 1        * denominator
     JMP STORE_NUM
     ENTA 1        * numerator
     ST1  N
     LDX  N
     JMP STORE_NUM
* TEMP is N
     ENT3 0           * loop for as long as A and X are not 1/1 (numerator/denominator = Xn/Yn)
STOP ENT4 1
LOOP LDA  YBUFFER,3     * A = Yk
     ADD  N             * A = Yk + n
     SRAX 5
     DIV  YBUFFER,4     * A = (Yk + n)/Y(k+1)
     STA  YBUFFER,2
     MUL  XBUFFER,4     * A = A*X(k+1)
     SLAX 5
     SUB  XBUFFER,3     * A = A - Xk
     STA  XBUFFER,2
     LDA  YBUFFER,2     * A = (Yk + n)/Y(k+1) A
     MUL  YBUFFER,4     * A = A * YK+1
     SLAX 5
     SUB  YBUFFER,3     * A = A - Yk
     SRAX 5             * X = Yk+2
     LDA  XBUFFER,2      * A = xk+2
     INC3 1
     INC4 1
     JMP STORE_NUM
     CMPA =1=
     JNE  LOOP
     CMPX =1=
     JNE  LOOP

     JMP PRINT_NUMS
     HLT

* Assume that A is the numerator and X is the denominator
* I2 is the index into the buffer
STORE_NUM  STJ  SN_EXIT
           STA  XBUFFER,2
           STX  YBUFFER,2
           INC2 1
SN_EXIT    JMP  *

*I2 is the index into the buffer
PRINT_NUMS STJ  PN_EXIT
           ST2  TEMP
           ENT2 0
PN_LOOP    LDA XBUFFER,2
           CHAR
           STX BUFFER(1:2)
           ENTA 47            * slash
           STA BUFFER(3:3)
           LDA YBUFFER,2
           CHAR
           STX BUFFER(4:5)
           OUT BUFFER(18)
           INC2 1
           CMP2 TEMP
           JL   PN_LOOP
PN_EXIT    JMP  *

BUFFER  ALF    /
        ORIG *+24
XBUFFER ORIG *+100
YBUFFER ORIG *+100
TEMP    CON 0
N       CON 0

* Trace routine (from 1.4.3.2)
* X is leave location
* I2 must be zero
ENTER      STX  VALUE_EXITLOC,2
           STX  VALUE_XREG,2
           ST1  VALUE_I1REG,2
           ST2  VALUE_I2REG,2
           STA  VALUE_AREG,2   * save for later
           STJ  VALUE_JREG,2   * save for later
           LDA  VALUE_JREG,2(0:2)
CYCLE      STA  VALUE_PREG,2
           SUB  VALUE_EXITLOC,2
           JAZ  LEAVE  * if we're zero, it means we are exactly the exit condition
           LD1  VALUE_PREG,2
           LDA  0,1
           STA  VALUE_INST,2
           SRA  2


*  save off instruction writing

           STA  VALUE_INST1,2(0:3)
* set F to 2
           ENTA 2
           STA  VALUE_INST1,2(4:4)
* Set C to 48 (ENTA)
           ENTA 48
           STA  VALUE_INST1,2(5:5)
           LDA  INST1_TMPL+1
           STA  VALUE_INST1+1,2

           LDA INST_TMPL+1
           STA VALUE_INST+1,2
           LDA INST_TMPL+2
           STA VALUE_INST+2,2
           LDA INST_TMPL+3
           STA VALUE_INST+3,2

           LDA JUMP_TMPL
           STA VALUE_JMP,2
           LDA JUMP_TMPL+1
           STA VALUE_JMP+1,2



           LDA  VALUE_INST,2(5:5)
           DECA 38    * check if its a jump instruction
           JANN 1F
           INCA 6
           JANZ 2F
           LDA  VALUE_INST,2(0:4) * is a stj instruction

* write out STJ instruction
           STA  VALUE_STJ,2(0:4)
           ENTA 24
           STA  VALUE_STJ,2(5:5)
           LDA  STJ_TMPL+1
           STA  VALUE_STJ+1,2

           LDA  VALUE_JREG,2
           JMP  VALUE_STJ,2
STJBACK    JMP  INCP * skip running intruction, we do the store jump manually
2H         DECA 2
           JANZ 2F
           JMP  3F
1H         DECA 9
           JAP  2F
3H         LDA  8F(0:3)
           STA  VALUE_INST,2(0:3)
2H         ST2  VALUE_I2SAVED,2
           LDA  VALUE_AREG,2
           LD1  VALUE_I1REG,2
           LD2  VALUE_I2REG,2

           JMP  VALUE_INST   * jump to instruction

INSTBACK   ST1  VALUE_I1REG
           STA  VALUE_AREG

INCP       LDA  VALUE_PREG,2   * move to next instruction
           INCA 1
           JMP  CYCLE

8H         JSJ  JUMP

JUMP       JMP  VALUE_JMP
           LDA  8B(4:5)
           SUB  VALUE_INST,2(4:5)
           JAZ  *+4
           LDA  VALUE_PREG,2
           INCA 1
           STA  VALUE_JREG,2
INST1      JMP  VALUE_INST1,2
INST1BACK  JMP  CYCLE


LEAVE      LDX  VALUE_XREG,2
           STX  LEAVEX(0:2)
           LDA  VALUE_AREG,2

           LD1  VALUE_I1REG,2
           LD2  VALUE_I2REG,2

LEAVEX     JMP  *

           END START
           ORIG 1000


STJ_TMPL      STA  *
              JMP  STJBACK

INST_TMPL     CON  *
              ST2  VALUE_I2REG
              LD2  VALUE_I2SAVED
              JMP  INSTBACK

JUMP_TMPL     LD2  VALUE_I2SAVED
              JMP  JUMP+1


INST1_TMPL    ENTA  *
              JMP INST1BACK

VALUE_AREG    CON  0
VALUE_XREG    CON  0
VALUE_I1REG   CON  0
VALUE_I2REG   CON  0
VALUE_I2SAVED CON  0
VALUE_PREG    CON  0
VALUE_JREG    CON  0
VALUE_EXITLOC CON  0

VALUE_INST1   CON  0
VALUE_INST1BK CON  0

VALUE_STJ     CON  0
VALUE_STJBCK  CON  0

* meant to represent an instruction call
VALUE_INST    CON  0
              CON  0
              CON  0
              CON  0


* mean to represent what to call with a jump
VALUE_JMP     CON  0
              CON  0
