* Differentiation in a right threaded  tree

LLINK           EQU     4:5
RLINK           EQU     1:2
RLINKT          EQU     0:2
TYPE            EQU     3:3

MAIN            ORIG    100
                JMP SETUPMEM
                JMP SETUPTREE

                ENT1 Y
                JMP PRINT_EQ
                JMP CLEAR_OUTBUF
                OUT OUTBUF(18)
                
                JMP D1

                ENT1 DY
                JMP PRINT_EQ
                JMP CLEAR_OUTBUF
                OUT OUTBUF(18)

                ENT1 DY
                JMP  REDUCE
                ENT1 DY
                JMP PRINT_EQ
                HLT

SETUPMEM    STJ 9F
            LD1 AVAIL
1H          ENT2 0,1
            
            INC2 2
            ST2 0,1(LLINK)
            ENT1 0,2
            CMP1 =MEMORY+2000=
            JL   1B

9H          JMP *

SETUPTREE   STJ 9F
            
* set up right links of trees
            ENNA Y 
            STA Y(RLINKT)
            ENNA DY
            STA  DY(RLINKT)

            ENT1  VARX
            JMP   COPY
            ENT2 0,1

            ENT1 CON1
            JMP  COPY

            ENTX 0,2
            ENTA  PLUS
            JMP   TREE2

            ENTA  LOG
            JMP   TREE1
            
            ENT2 0,1

            ENT1 CON2
            JMP  COPY
            ENTA 3
            STA 1,1
            
            ENTX 0,1
            ENTA TIMES
            ENT1 0,2
            JMP TREE2   * left half at this point in I1

            ENT2 0,1

            ENT1 VARX
            JMP COPY
            ENT5 0,1

            ENT1 CON2
            JMP COPY
            ENTA UPARROW
            ENTX 0,5
            JMP TREE2

            ENT3  0,1
            ENT2  Y
            JMP   INSERT_LEFT

9F          JMP *

* MAIN CONTROL ROUTINE
D1              STJ     9F
                LD4     Y(LLINK)
1H              ENT2    0,4    * go down until left link is null
2H              LD4     0,2(LLINK)
                J4NZ    1B
D2              LD1     0,2(TYPE)  * let's do the Differentiation
                JMP     TYPETABLE,1
TYPETABLE       JMP     CONSTANT
                JMP     VARIABLE
                JMP     LN
                JMP     NEG
                JMP     ADD
                JMP     SUB
                JMP     MUL
                JMP     DIV
                JMP     PWR
D3              ST3     0,4(RLINK)   * restore the link
D4              ENT3    0,2
                LD2     0,2(RLINKT)
                J2N     1F
                ST5     0,3(RLINK)
                JMP     2B
1H              ENN2    0,2
D5              ENT1    0-Y,2
                LD4     0,2(LLINK)
                LD6     0,4(RLINK)
                J1NZ    D2
                ST5     DY(LLINK)
                ENNA    DY
                STA     0,5(RLINKT)
9H              JMP     *

* TREE construction

TREE0           STJ     9F
                JMP     2F
TREE1           ST1     3F(0:2)
                JSJ     1F
TREE2           STX     3F(0:2)
3H              ST1     *(RLINKT)
1H              STJ     9F
                LDXN    AVAIL
                JXZ     OVERFLOW
                STX     0,1(RLINKT)
                LDX     3B(RLINKT)   * in this case, X is U
                STA     *+1(0:2)      * copies over root node
                STX     *(LLINK)
2H              LD1     AVAIL
                J1Z     OVERFLOW
                LDX     0,1(LLINK)
                STX     AVAIL
                STA     *+1(0:2)
                MOVE    *(2)
                DEC1    2
9H              JMP     *

COPYP1          ENT1    0,4
                JSJ     COPY
COPYP2          ENT1    0,3
COPY            STJ     9F
* assume I1 is the node to be copied and no other register can be used (or at least restored)
                ST2     RESTORE2(0:2)
                ST3     RESTORE3(0:2)
                ST4     RESTORE4(0:2)
                ST5     RESTORE5(0:2)
                ST6     RESTORE6(0:2)
CREATEROOT      LD2     AVAIL   * root node
                LDX     0,2(LLINK)
                STX     AVAIL
                STZ     0,2
                ENT6    0,2

C2              LDA     0,1(RLINKT)
                JANP    C3

                LD3     AVAIL
                LDX     0,3(LLINK)
                STX     AVAIL
                STZ     0,3

                JMP    INSERT_RIGHT

C3              LDA     1,1
                STA     1,2

                LDA     0,1(TYPE)
                STA     0,2(TYPE)

C4              LDA     0,1(LLINK)
                JAZ     C5

                LD3     AVAIL
                LDX     0,3(LLINK)
                STX     AVAIL
                STZ     0,3

                JMP INSERT_LEFT

C5              ENT3 0,1
                JMP PRE_SUCC
                ENT1 0,3

                ENT3 0,2
                JMP PRE_SUCC
                ENT2 0,3 
                J2NZ C2  *  check if our algorithm is done, since our new node

                ENT1 0,6

RESTORE2        ENT2     *
RESTORE3        ENT3     *
RESTORE4        ENT4     *
RESTORE5        ENT5     *
RESTORE6        ENT6     *
9H              JMP      *

PRE_SUCC     STJ 9F
             ENT5 0,3
S1           LD3 0,3(LLINK)
             J3P 9F 
             ENT3 0,5
S2           LD5 0,3(RLINKT)
             LD3 0,3(RLINK) 
             CMP3 0,3(RLINK)
             JE 9F  *  we are pointing to ourself
             J5N S2
9H           JMP *

* I3 is node to insert, I2 is node to insert right of
INSERT_RIGHT     STJ 9F
                 LD4 0,2(RLINKT)
                 ST4 0,3(RLINKT)
                 STZ 0,3(LLINK)
                
                 ST3 0,2(RLINKT)
9H               JMP * 


* I3 is node to insert, I2 is node to insert left of
INSERT_LEFT  STJ 9F
            
             ST3 0,2(LLINK)
             ENT5 0,3
1H           LD4 0,5(RLINKT)
             J4P 2F
             ENN4 0,2
             ST4 0,5(RLINKT)
             JMP 9F
2H           ENT5 0,4
             JMP 1B
              
9H           JMP *


CON0            CON     0
                CON     0
CON1            CON     0
                CON     1
CON2            CON     0
                CON     2
LOG             CON     4096*2 
                ALF     LN
NEGOP           CON     4096*3
                ALF    NEG  
PLUS            CON     4096*4
                ALF     +
MINUS           CON     4096*5
                ALF     -
TIMES           CON     4096*6
                ALF     *
SLASH           CON     4096*7
                ALF     /
UPARROW         CON     4096*8
                ALF     **
VARX            CON     4096
X               ALF      X

* DIFFERENTIATION ROUTINES
GOTOCTRL        ENT5    0,1
                JMP     D4
VARIABLE        LDX     1,2
                ENTA    CON1
                CMPX    X 
                JE      *+2 
CONSTANT        ENTA    CON0       
                JMP     TREE0
                JMP     GOTOCTRL

LN              LDA     1,5
                JAZ     D4
                JMP     COPYP1
                ENTX    0,5
                ENTA    SLASH
                JMP     TREE2
                JMP     GOTOCTRL

NEG             LDA     1,5
                JAZ     D4
                ENTA    NEGOP
                ENT1    0,5
                JMP     TREE1
                JMP     GOTOCTRL

ADD             LDA     1,6
                JANZ    1F
3H              LDA     AVAIL
                STA     0,6(LLINK)
                ST6     AVAIL
                JMP     D3
1H              LDA     1,5
                JANZ    1F
2H              LDA     AVAIL
                STA     0,5(LLINK)
                ST5     AVAIL
                ENT5    0,6
                JMP     D3
1H              ENTA    PLUS
4H              ENTX    0,6
                ENT1    0,5
                JMP     TREE2
                ENT5    0,1
                JMP     D3

SUB             LDA     1,5
                JAZ    2B
                LDA     1,6
                JANZ    1F
                ENTA    NEGOP
                ENT1    0,5
                JMP     TREE1
                ENT5    0,1
                JMP     3B
1H              ENTA    MINUS
                JMP     4B

MUL             LDA     1,6
                JAZ     1F
                JMP     COPYP2
                ENTA    0,6
                JMP     MULT
                ENT6    0,1
1H              LDA     1,5
                JAZ     ADD
                JMP     COPYP1
                ENTA    0,1
                ENT1    0,5
                JMP     MULT
                ENT5    0,1
                JMP     ADD

MULT            STJ     9F
                STA     1F(0:2)
                ST2     8F(0:2)
1H              ENT2    *
                LDA     1,2
                DECA    1
                JANZ    1F
                LDA     0,2(TYPE)
                JAZ    2F
1H              LDA     1,1
                DECA    1
                JANZ    1F
                LDA     0,1(TYPE)
                JANZ    1F
                ST1     *+2(0:2)
                ENT1    0,2
                ENT2    *
2H              LDA     AVAIL
                STA     0,2(LLINK)
                ST2     AVAIL
                JMP     8F
1H              ENTA    TIMES
                ENTX    0,2
                JMP     TREE2
8H              ENT2    *
9H              JMP     *

*     D(u**v) == DU x (v x (u ** (v - 1))) + ((ln(u) x d(v))) x (u ** v)
*                        +
*                        |
*                        *------------------------*
*                        |                        |
*                        DU-----*                 *----------------**
*                               |                 |                |
*                               v---- **          ln-----d(v)      u------v
*                                     |           |
*                                     u--- -      u
*                                          |
*                                          v------1
*     P1 == U I4, P2 == V I3 , Q1 == D(U I6), Q2 == D(V) I5
PWR             ST1     PWR_REST(0:2)
                ST2     PWR_REST+1(0:2)
                ST3     PWR_REST+2(0:2)
                ST4     PWR_REST+3(0:2)

                ENT1    0,3
                JMP     COPYP2
                ENT2    0,1
                
                ENT1    CON1
                JMP     COPY
                ENT1    0,1

                ENTA    MINUS
                ENTX    0,2

                JMP     TREE2   * i1 = v-1

                ENT2    0,1

                JMP     COPYP1
                ENTX    0,1
                ENTA    UPARROW

                ENT1    0,2

                JMP    TREE2    * i1 = u ** (v-1)
                ENT2   0,1

                LD3    PWR_REST+2(0:2)
                JMP    COPYP2
                ENTA   0,1

                ENT1   0,2

                JMP    MULT

                ENT2   0,1

                ENT1   0,6
                JMP    COPY
                ENTA   0,1

                ENT1   0,2
                JMP    MULT   * I1 is now the full left side of the multiplication tree

                ENT2   0,1     (* now its I2)

                JMP    COPYP1
                ENTA   LOG 
                JMP    TREE1   * I1 now is ln(u)

                ENTA   0,1
                ENT1   0,5
                JMP    MULT  * I1 is now (ln(u) * d(v))
                ENT5   0,1

                LD4   PWR_REST+3(0:2)   * I4 / U
                JMP   COPYP1
                ENT4  0,1

                LD3   PWR_REST+2(0:2)
                JMP   COPYP2

                ENTX  0,4
                ENTA  UPARROW
                JMP   TREE2

                ENTA  0,5
                JMP   MULT

                ENTX   0,2
                ENTA   PLUS
                JMP    TREE2  *  put both sides together


                ENT5    0,1


PWR_REST        ENT1    *
                ENT2    * 
                ENT3    * 
                ENT4    *
9H              JMP     D3 


*     D(u/v) == DU/v - (u * Dv) / (v ** 2)
*                        -
*                        |
*                        /------------------------/
*                        |                        |
*                        DU-----v                 *----------------**
*                                                 |                |
*                                                 u-----d(u)       v------2
*     P1 == U I4, P2 == V I3 , Q1 == D(U I6), Q2 == D(V) I5

DIV             ST1     DIV_REST(0:2)
                ST2     DIV_REST+1(0:2)
                ST6     DIV_REST+2(0:2)
                JMP     COPYP2
                ENTX    0,6

                ENTA    SLASH
                JMP     TREE2
                ENT6    0,1  *  I6 is now DU/V

                JMP     COPYP1
                ENTA    0,1
                ENT1    0,5
                JMP     MULT
                ENT5    0,1   * I5 is now u* du

                JMP     COPYP2
                ENT2    0,1
                
                ENT1    CON2
                JMP     COPY


                ENTX    0,2
                ENTA    UPARROW
                JMP     TREE2

                ENTX    0,5
                ENTA    SLASH
                JMP     TREE2

                ENTX    0,6
                ENTA    MINUS
                JMP     TREE2

                ENT5    0,1
DIV_REST        ENT1    *
                ENT2    *
                ENT6    *
9H              JMP     D3 

* I1 should be the tree to reduce.
* I6 will track if there are reductions or not
REDUCE          STJ     9F
                ST1     1F(0:2)
1H              ENT1    * 
                ENT6    0
                JMP     TRY_REDUCTION
                J6NZ    1B
9H              JMP     *


TRY_REDUCTION   STJ     9F

                ENT3    0,1
1H              JMP     PRE_SUCC
                DEC3    0,1
                J3Z     9F
                INC3    0,1
                JMP     TRY_REDUCE
                J6NZ    9F
2H              DEC3    0,1
                J3Z     9F
                INC3    0,1
                JMP     1B
9H              JMP     *

* i3 is the node to check, I6 is 1 if a reduction
TRY_REDUCE      STJ     9F
                JMP     IS_ARITH_CON
                J6Z     HANDLE_ZEROES
*                J6Z     HANDLE_ONES
                J6Z     CON_FRAC_MULT
9H              JMP     *

IS_ARITH_CON    STJ     9F
                LD4     0,3(LLINK)  *I4 is the first node
                LDA     0,4(TYPE)
                JANZ    9F       * left node not constant
                LDA     1,4       * A is value
                LD4     0,4(RLINK)  * 4 is the right node
                LDX     0,4(TYPE)
                JXNZ    9F      * right node not constant
                LDX     1,4

                ENT2    LBL_ARITH_CON

                LD5     0,3(TYPE)   * 5 is the type
CON_CHK_ADD     CMP5    PLUS(TYPE) 

                JNE     CON_CHK_SUB
                JMP     PRINT_REDUC

                ADD     1,4
               
                JMP     CLEANUP_CON 
                
CON_CHK_SUB     CMP5    MINUS(TYPE) 
                JNE     CON_CHK_MULT
                JMP     PRINT_REDUC
                SUB     1,4
                JMP     CLEANUP_CON

CON_CHK_MULT    CMP5    TIMES(TYPE) 
                JNE     CON_CHK_DIV
                JMP     PRINT_REDUC
                MUL     1,4
                JAZ     1F   
                DIV     1,4 * too big for one register
                JMP     CON_CHK_DIV
1H              SLAX    5
                JMP     CLEANUP_CON
CON_CHK_DIV     CMP5    SLASH(TYPE) 
                JNE     CON_CHK_PWR
                STA     1F(0:2)
                STX     2F(0:2)
                SRAX    5
                DIV     1,4
                JXZ     1F
                STX     *+2(0:2)  * uneven divide, multiply it back and add the remainder
                MUL     1,4   * 
                INCX    *     
                SLAX    5
                JMP     CON_CHK_PWR
1H              ENTA    *
2H              ENTX    *
                JMP     PRINT_REDUC
                SRAX    5
                DIV     1,4
                JMP     CLEANUP_CON
CON_CHK_PWR     CMP5    UPARROW(TYPE) 
                JNE     9F
 
                JMP     PRINT_REDUC
                STA     ORIGINALA(0:2)
                LD2     ORIGINALA(0:2)
                ENT1    0,4 
                LD4     1,4
1H              DEC4    1
                J4NP    UPDATE_PWR 
                MUL     1,1
                JANZ    ORIGINALA  * we got too big
                SLAX    5
                JMP     1B
UPDATE_PWR      ENT4    0,1
                JMP     CLEANUP_CON 
ORIGINALA       ENTA    0,2
                ENT4    0,1
                JMP     9F
CLEANUP_CON     JMP     REPLACE_ROOT_A
                ENT6    1
9H              JMP     *

* A is left, X is right, 3 is root node, set 6 to 1 if A is text, or 2 if X is text
PRINT_REDUC     STJ     9F
                STA     1F(0:2)
                ST2     3F(0:2)
                ST2
                ENT2    0,1
                ENT1    OUTBUF
3H              MOVE    LBL_ARITH_CON(4)
                LD1     1,3
                ST1     OUTBUF+6
                STX     2F(0:2)
                CMP6    =1=
                JE      4F
                CHAR
                STX     OUTBUF+5
                JMP 2F
4H              STA     OUTBUF+5
2H              ENTX    *
                CMP6    =2=
                JE      4F
                SLAX    5
                CHAR
4H              STX     OUTBUF+8
                OUT     OUTBUF(18)
                JMP     CLEAR_OUTBUF
                ENT1    0,2
1H              ENTA    *

9H              JMP     *

*I3 is the root node, only cleans direct children
CLEAN_CHILDREN  STJ   9F
                LD6     0,3(LLINK)  * return memory
                LDX     AVAIL
                STX     0,6(LLINK)
                ST6     AVAIL
                STZ     0,3(LLINK)

1H              LD6     0,6(RLINKT)
                J6NP    9F
                LDX     AVAIL
                STX     0,6(LLINK)
                ST6     AVAIL
                JMP     1B


9H               JMP   *
* Sets the root node, and cleans up memory below
* at this point, I3 is the root node, A is the value to update
REPLACE_ROOT_A  STJ     9F
                STA     1,3
                STZ     0,3(TYPE)  * make it a new constant

                JMP     CLEAN_CHILDREN 

2H              JANN    9F  * add a neg node
                ENT4    0,3  
                JMP     COPY
                ENTA    NEGOP
                JMP     TREE1
                LDA     0,4(TYPE)
                STA     0,3(TYPE)
                LDA     1,4
                STA     1,3

                LDA     0,4(LLINK)
                STA     0,3(LLINK)

                LD1     0,3(LLINK)
                ENN3    0,3
                ST3     0,4(RLINKT)
9H              JMP     *


* Assuming I6 is the tree with an zero right link, clean it up
CLEANUP_TREE    STJ     9F
                ENT5    0,6
                JMP     2F
SS3             ENT6    0,5
                LD5N    1,5(RLINKT) 
                J5Z     9F
                LDA     AVAIL
                STA     0,6(LLINK)
                ST6     AVAIL    * return memory
SS1             J5NN    1F
                ENN6    0,5
SS2             ENT5    0,6
2H              LD6     0,5(LLINK)
                J6P     SS2 
                JMP     SS3 
                
9H              JMP     *
                
HANDLE_ZEROES   STJ     9F
                LD5     0,3(TYPE)
                CMP5    CONSTANT(TYPE)
                JE      9F
                CMP5    VARIABLE(TYPE)
                JE      9F
                CMP5    LOG(TYPE) 
                JE      9F
                LD2     0,3(LLINK)  *I2 is the left link
                LDA     0,2(TYPE)
                JANZ    CHECK_ZRIGHT
                LDA     1,2
                JANZ    CHECK_ZRIGHT
                CMP5    TIMES(TYPE)
                JE      1F
                CMP5    SLASH(TYPE)
                JE      1F
                CMP5    UPARROW(TYPE)
                JE      1F
                CMP5    NEGOP(TYPE)
                JE      1F
* for add and minus
                JMP     9F 
1H              ENTA    0     * just set zero to the root node
                ENT6    2
                LD4     0,2(RLINK)
                LDX     1,4 
                ENT2    LBL_ZERO_NODE
                JMP     PRINT_REDUC 
                JMP     REPLACE_ROOT_A
                ENT6    1
                JMP     9F
CHECK_ZRIGHT    ENT4    0,2    * 4 is the left link
                LD2     0,2(RLINKT)  * 2 is the right link
                LDA     0,2(TYPE)
                JANZ    9F
                LDX     1,2
                JXNZ    9F
                CMP5    TIMES(TYPE)
                JE      1F
                CMP5    UPARROW(TYPE)
                JE      2F
* the right node is a zero of a + or minus. Grab llink, type, and value,
* of the root's left and move it to the root node. Re-thread new left's far right
* node to point to root
                ENT2   LBL_ZERO_NODE
                ENT6   1
                LDA    1,4 
                ENTX   0
                JMP    PRINT_REDUC


                JMP    REPLACE_ROOT_NODE
                ENT6   0,1
                JMP    9F
1H              ENT2   LBL_ZERO_NODE
                ENT6   1
                LDA    1,4 
                ENTX   0
                JMP    PRINT_REDUC

                ENTA    0
                JMP     8F
2H              NOP     * replace with 1
8H              JMP     REPLACE_ROOT_A
                ENT6    1
9H              JMP     *

*I3 is the root, I4 is the node to copy up
REPLACE_ROOT_NODE STJ   9F
                LDA    1,4
                STA    1,3
                LDA    0,4(3:5) * tag and left link
                JMP    CLEAN_CHILDREN
                STA    0,3(3:5)
                LD6    0,3(LLINK)
3H              ENT2   0,6
                LD6    0,6(RLINKT)
                J6N    4F * are we at our thread
                JMP    3B
4H              ST3    0,2(RLINK)
9H                JMP   *

HANDLE_ONES     STJ     9F
                LD5     0,3(TYPE)
                CMP5    CONSTANT(TYPE)
                JE      9F
                CMP5    VARIABLE(TYPE)
                JE      9F
                CMP5    LOG(TYPE) 
                JE      9F
                CMP5    PLUS(TYPE) 
                JE      9F
                CMP5    MINUS(TYPE) 
                JE      9F
                CMP5    NEGOP(TYPE) 
                JE      9F
                LD2     0,3(LLINK)  *I2 is the left link
                LDA     0,2(TYPE)
                JANZ    CHECK_ORIGHT
                LDA     1,2
                CMPA    =1=
                JNE     CHECK_ORIGHT
                CMP5    TIMES(TYPE)
                JE      1F
                CMP5    SLASH(TYPE)
                JE      9F
                CMP5    UPARROW(TYPE)
                JE      2F
                LD4     0,2(RLINK)
                
* the right node is a one of a * or /. Grab llink, type, and value,
* of the root's left and move it to the root node. Re-thread new left's far right
* node to point to root
1H              ENT2   LBL_ONE_NODE
                ENT6   2
                ENTA   1
                LDX    1,4
                JMP    PRINT_REDUC

                JMP    REPLACE_ROOT_NODE
                ENT6   1 
                
                JMP    9F

2H              JMP     9F
CHECK_ORIGHT    ENT4    0,2    * 4 is the left link
                LD2     0,2(RLINKT)  * 2 is the right link
                LDA     0,2(TYPE)
                JANZ    9F
                LDX     1,2
                CMPX    =1=
                JNE     9F
                CMP5    TIMES(TYPE)
                JE      1F
                CMP5    SLASH(TYPE)
                JE      1F
                CMP5    UPARROW(TYPE)
                JE      2F

1H              JMP     9F
2H              NOP     * replace with base
8H              JMP     REPLACE_ROOT_A
                ENT6    1
9H              JMP     *



CON_FRAC_MULT   STJ     9F
                LD5     0,3(TYPE)
                CMP5    TIMES(TYPE)
                JNE     9F
                LD4     0,3(LLINK)  * 4 is on left
                LD5     0,4(RLINK) * 5 is on right
                LDA     0,4(TYPE)
                CMPA    CONSTANT(TYPE)
                JE      1F
                LDA     0,5(TYPE)
                CMPA    CONSTANT(TYPE)
                JNE     9F
                ENT2    0,5
                ENT5    0,4
                ENT4    0,2 * swap the two so constant is on left
1H              LDA     0,5(TYPE)
                CMPA    SLASH(TYPE)
                JNE     9F

                LDA    1,4
                CMPA   =0=
                JAZ    9F
                CMPA   =1= 
                JE     9F

                LD2    0,5
                ENT6   2
                LDX    1,5
                ENT2   LBL_CON_FRAC
                JMP    PRINT_REDUC
                ENT6   0

                ST1     7F(0:2)  * save off I1
                ENT1    0,4
                JMP     COPY
                ENTA    0,1
                LD1     0,5(LLINK)   * numerator
                ENT6    0,1  * save off old numerator
                LD2     0,1(RLINKT)
                STZ     0,1(RLINKT)  * null it out so we don't have a thread (For cleanup)
                JMP     MULT   * multiply left constant with numerator 
                ST1     0,5(LLINK)
                ST2     0,1(RLINKT)

                JMP     CLEANUP_TREE

                ENTA    1
                STA     1,4
7H              ENT1    *
                ENT6    1
* further reduces will take care of simplifying the fraction

9H              JMP     *


PRINTTERM       STJ     9F
                CMP4    =24=
                JNE      1F
                OUT     OUTBUF(18)
                ENT1    OUTBUF
                MOVE    EMPTY(24)
                ENT4    0
1H              STA     OUTBUF,4
                INC4    1
9H              JMP     *


PRINT_EQ        STJ     9F
                ENT4    0
                ST1     TEMP
                ENT3    0,1
1H              JMP     PRE_SUCC
                CMP3    TEMP 
                JE      8F
PRINT_NODE      LDA     1,3
                LD2     0,3(TYPE)
                J2Z     PRINT_NUM 
                JMP     PRINTTERM
                JMP     2F 
PRINT_NUM       CHAR
                SLAX    5
                JMP     PRINTTERM
2H              ENTA    0 
                JMP     PRINTTERM
3H              JMP     1B
8H              OUT     OUTBUF(18)
9H              JMP     *
TEMP            CON     0
                
CLEAR_OUTBUF    STJ     9F
                ENT1    OUTBUF
                MOVE    EMPTY(24)
9H              JMP     *

OVERFLOW        HLT
UNDERFLOW       HLT

* LABELS
LBL_ARITH_CON   ALF ARITH
                ALF METIC
                ALF   CONS
                ALF TANT 
LBL_ZERO_NODE   ALF ZERO
                ALF NODE
                CON 0
                CON 0
LBL_ONE_NODE    ALF ONE N
                ALF ODE 
                CON 0
                CON 0
LBL_CON_FRAC    ALF CONST
                ALF ANT F
                ALF RACTI 
                ALF ON 

Y               CON 0
                CON 0
DY              CON 0
                CON 0
OUTBUF          ORIG *+24
EMPTY           ORIG *+24
AVAIL           CON MEMORY
MEMORY          ORIG *+2000
                END MAIN