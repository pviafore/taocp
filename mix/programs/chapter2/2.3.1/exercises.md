1)  In the binary tree (2), what is INFO(LLINK(RLINK(RLINK(T))))

   H

2)  List the nodes of a binary tree in pre-order, in-order, post-order

    1,2,4,5,3,6,7

    4,2,5,1,6,3,7

    4,5,2,6,7,3,1

3)  Are the terminal nodes of a binary tree always in the same order regardless of traversal strategy?

    Yes, becasue you always check nodes in the same order, left-tree then right tree. Whether we print them out or not doesn't matter at the terminal nodes, because there are no left or right subtrees.

    So you always will hit the left most node before hitting any other terminal node.

4)  What about a right-first pre-order?

    1,3,7,6,2,5,4  , which is the reverse of a post-order traversal

5)  When using a binary representation of trees(0 for left, 1 for right), what is pre, in , and post order traversal described as.

    1, 10, 100, 101, 11, 110, 111  (pre-order is a lexicographic sort of nodes)

    100, 10, 101, 1, 110, 11, 111 (in-order is a lexicographic sort if "empty" is > 0 but < 1)

    100, 101, 10, 110, 111, 11, 1 (post-order lexicographic sort if "empty" > 1)

6)  Show that a permutation of indices generated can be generated by putting 1,2,...,N into a stack and popped strategically

    So for in-order, you push the numbers onto the stack until you've pushed a terminal node. If you hit a terminal node, immediately pop that node, and the node following as long as the stack is non empty

    If pre-order is 
    
    1,2,4,5,3,6,7

    ```
    push 1
    push 2
    push 3
    pop  3
    pop  2
    push 4
    pop  4
    pop  1
    push 5
    push 6
    pop  6
    pop  5
    push 7 
    pop  7
    ```

    Which means you pop the indices as 3,2,4,1,6,5,7, which gives a in-order as 4,2,5,1,6,3,7.

    This works because if you are a left node, then you pop yourself, and then pop your parent, who was the next node up (and the "visit" after visiting you the left).

    If you are a right node, then you pop yourself (you have nowhere to travel to the right), and by popping the next node, you are popping your ancestor who traversed left first.

7)  Show that if we are given the pre-order and post-order traversal, we can construct the structure

    We can't do pre-order alone, as it doesn't distinguish between

    (1, (2, (3))) (all left links)

    and

    (1, (2, 3)) (triangle structure)

    In-order doesn't distinguish between

    (1, (2, (3)))

    and 

    (2, (3 1))

    So it can't be one alone.

    A pre-order will confuse a list of left only links and the triangle structure, but we can cross reference the in-order traversal at the same time (it is convenient that we can binary search through in-order traversal to find out what node we should be on) and see if it matches up.

    Post-order and in-order should be able to rectify things as well for the same reason.

    However, pre-order and post-order will not give an answer, as a simple (A, (B)) link will confuse them. For both, the answer is AB and BA, but there is no way to tell if B is the left link or the right link in this case (the in-order will bisect to tell us which link a side is on.) 


8)  Find all binary trees whose nodes appear in exactly the same sequence in 

    a) pre order and in order

    Any trees that are comprised of only right links

    b)  pre-order and post-order

    Any two trees which have only a root

    c) inorder and postorder 

    Any two trees that only have left links

9) When a binary tree having n nodes is traversed using Algorithm T, how many times is T1, T2, T3, T4 and T5 performed?

    T1 - just once
    T2 - this happens after every visit of a node, as well as every left descend. We can be up to n left descends on the worst case, so let's say 2n on the worst case and on the average case (a balanced tree?), it would be 1.5n
    T3 - This happens N times, for each tree that we have
    T4 - This happens N+1 times ( each node and the final condition of stack empty)
    T5 - This happens N times

10) What is the largest number of entries that can be in the stack at once, if the binary tree has n nodes for traversal?

    It can be N if we just have a giant list of left links. In a balanced tree, $lg_n$.

11) Analyze the average value of the largest stack size?

    oof a higher math problem. I suspect it is on average (warning my math is probably suspect) $\frac{n + lg_n}{2} $. The reason being is that you have a balanced tree in the middle (which is $lg_n$, but then as you unbalance, you get either to llinks only or rlinks only). With llinks only, you'll tend to more to n and with rrlinks only, you'll tend more to zero. Since we're we can take a symmetric reflection of that tree at any time, you're going to have some part of your tree balanced which is $lg_n$ stack depth, and the remainder if either tending to the rest of the n nodes or zero. On average, I say that's probably half balanced, half unbalanced (it reality it probably tends more to unbalanced, which would mess with my fractions). So I'm just guessing at what the depth would actually be,'

    And now that I look at the answer in the book, I'm nowhere close (or rather, I'm nowhere close to knowing how close I am to the answer). This math is beyond me. If you want the right answer, read the book :)

12) Design an algorithm to traverse a binary tree in pre-order and prove that your algorithm is correct.

    See [preorder.mixal](preorder.mixal). Also note that I have [inorder.mixal](inorder.mixal) for comparison.

    The big thing is you visit the node before you add it to the stack.

13) Cool cool, now do post-order

    See [postorder.mixal](postorder.mixal)

    In essence, I just keep the elements on the stack and track (in the stack) whether they were just pushed, have gone down the left, or gone down the right. If we went down the right, pop it

14) Show that a binary tree with n nodes has a function of n that expresses the amount of of null links.

    The number of null links is always n + 1.

    Consider the root node only. It has two empty links, which is 1 more than 1 (hopefully no advanced math is needed for that statement).

    As we add more nodes to that tree, we subtract a null link to place the node, which then adds two more null links (the newly added node will not have any children). Thus, we minus 1 null link, and add 2 , which gives us a net of +1 link. Given that we just added a node, we have n+1 nodes, and n + 1 + 1 links at this point. 

15) In a threade tree representation, what can we say between the number of links pointing to the node and some other property of the node?

    The number of links pointing to a node is the same as the number of children. Since we are dealing with in-order traversal, if the node has no children, the next node will be a parent, and there is nothing to point back "up" to this node. If we have a left child, then this node is a successor of the right most child of the left tree. If we have a right child, then this node is a predecessor of the left most child of the right tree. In either of those cases, there has to be a point-back to this node.

16) What's the rule for determining NODE(Q*) 

    If I have a left child, then that child is my successor. If I have no left child and a right child, then that node is my successor. If I have no children, then the successor of my parent is my successor (you may have to go all the way up the tree until you find it, in which case the successor will be the first right child of a parent that is not your ancestor (or none if there is none))

17) Give an algorithm analagous to Algorithm S for determining P* in a threaded binary tree.

    S1 If LTAG(P) == 0, P <- LLINK(P). Terminate
    
    S2 Else, if RTAG(P) = 0, P <- RLINK(P). Terminate. If RTAG(P) == 1, Repeat S2

    See [preorder_successor.mixal](preorder_successor.mixal)

18) Modfiy traversal and successor for double order

    For traversal, we are going to visit a node as we would in both pre-order and post-order. For successor, we will have to look at the index. If we are 1, then we need to look at the next node in pre-order, and if we are 2, then we need to look at next node in post-order. If we're a leaf, we will go to ourself if we are 1. Also, when checking for successor, if we find ourself with an empty left branch, and we are the first time through, we should do the in-order step then.

    See [double_order.mixal](double_order.mixal)

19) Design an algorithm that determines post-order successor in a right-threaded and a fully-threaded tree.

    For a right-threaded tree:

    Go right all the way down until you find your first thread. When you go that right link, you know you are the nearest ancestor for which you are in its left sub-tree (based on how in-order works).

    Now, we keep two pointers: one for the current node and one for its parent. We start them both at the ancestor. 

    Then we :

    S1: Go Left First

    S2: If node is the original node P, go to S4

    S3: Go right and repeat step S2

    S4: See below

    Now, we know who the direct parent is. If we're doing post-order, we need to know if P is the left node or the right node of the parent. If we're the right node, we just return the parent. If we're the left node though, we have to find the left most terminal node of the right child.

    See [post_successor_right_threaded.mixal](post_successor_right_threaded.mixal)

    There's probably a really neat trick for a fully-threaded tree, but I don't see it at the moment based on how I wrote my original algorithm.

20) Write Program T so that is uses a linked list as its stack.

    See [traversal_stack.mixal](traversal_stack.mixal).

21) Design an algorithm that goes through an in-order traversal of an unthreaded binary tree with no stack. Only link fields may be modified. 

    My main thought is to keep an auxillary variable that always points to the parent. You push onto the "stack" by saving the parent in the left child whenever you descend left. In a way, you are creating a linked list throughout the left trees.

    But this doesn't work when trying to restore the links. You only know the current node, and you are
    not guaranteed that is the child of the parent (since the parent is only the last time we went left).

    I thought we needed to also store the last left child, but I only had one word to work with, but two words need to be saved.

    So then I started seeing if there was a way to use the right link as well, but then I ran into the issue of knowing which child I was trying to restore.

    I couldn't use any other bits or signs, which makes it tough. So I was stuck, and looked at Knuth for a hint.

    In the answers, I didn't look through all of it, but saw a hint of adding a thread. Whenever I go left, I know there is a right null link all the way right. I could use the entire right link to store the parent.

    So whenever I descend left, I can then go all the way right and set that link to the parent. 

    So now what do I do when I need to restore? I can immediately get to the parent, but how do I know its the parent? I'm now back to square one.

    At this point I threw in the towel and went to go learn online. I found this [online resource](https://www.educative.io/answers/what-is-morris-traversal) to be a good explainer on how to do "Morris Traversal".

    The idea is that you do indeed make threads before you descend to the left. However, whenever you go go left or right down a tree, you need to make know if you went down a thread or not. You can find that out by going left once, then right all the time until null or you hit yourself (which means a thread). If its null, then you're fine, you went down left (in which case, make a thread). If you're right, then you should check to see if following the right of your left child leads to yourself (null it back out in this case), print yourself, then go right.

    See [inorder_nostack.mixal](inorder_nostack.mixal)

22) Write a program and compare time for Algorithm S and T

For each time we go to a node, we have to descend all the way to the right of the left subtree. Assuming an average depth of m throughout the tree, we have $m/2$ average nodes to go through to find the thread. We descend twice, at a cost of $4 + 3m$, plus additional for creating the thread or removing the thread. To create the thread, we have an additional cost of $3m/2$, but to remove the thread, we have an additional cost of $11m/2$. 

Comparing to S however, is even slower, because that is a constant operation (we already have the links generated). It's almost like we are doing S with an insert of link and remove of link before every visit.

23) Insert in a right threaded tree to the right, and the left.


    For inserting to the right, you don't need any right threads to be set up. See [insert_right.mixal](insert_right.mixal).

    For inserting to the left, we're going to follow the same sort of idea. Insert to the left child, using the pre-existing left child as your node's left. You will need to set up a right thread of your node to point to the parent, and the right most null link of the left child will set to you. See [insert_left.mixal](insert_left.mixal).

24) Is Theorem A still valid if T and T' are given in in-order instead of pre-order?

    I don't have the math to prove this, but it has to do with the fact that we don't know what the actual root is when givne in-order (the root is always first in pre-order)

25) Given a relation ≼, prove the transtive property, equivalence, and ordering.

    First, transitive. if T≼T' and T'≼T'', then T≼T''.

    So if T≼T', that means that one of four things:

    T is empty, which means that T will also ≼ T''.
    
    The root of T is ≼ than the root of T'. If the roots of T' and T'' are different, than since the info can be defined by ≼, we know that tracks as well. If the roots are the same betwen T' and T'', then we know that T will be ≼ than T'' (since T' and T'' have teh same root).

    Now, if the roots are the same between all of them, we have to look at the left tree, or the right tree. The same idea applies recursively.


    For equivalence, we are seeing if two trees are equivalent if T≼T' and T'≼T. Well, if one is empty, than the other must be empty, thus equivalent. Otherwise, we are looking at nodes and their relationship with ≼, which we know is fine.

    For any T, T', we either have T' ≼ T or T ≼ T'. First off, if the trees are equal, we know we have the ≼ relation. Otherwise, we are looking at the info of nodes, either at the root or recursively down a child, which we know satisfies ≼.

26) Given the ≼ ordering of trees, prove Theorem A, ande make use of double order.

    Since double order gives us pre and in order, exercise 7 tells us that we can tell if two trees are equivalent, as their construction must be the same. However, I have no idea how to tell if they are similar using the ≼ ordering on top of this.

27) WRite an algorithm that tests if two trees are ordered or equivalent, and its right-threaded. Don't use a stack.

    If we can't use a stack, then let's see what we can do in in-order traversal. First, keep going down the left branch, and see if any of those have the relationship. If they do, return the change. Otherwise, go right until you have a non-thread to go down. Because we always check the left first, we should be fine. See [ordering.mixal](ordering.mixal) 

28) If you copy a tree with Algorithm C, is the tree similar or equivalent.

    Equivalent, which implies similar.

29) Prove that Algorithm C is correct

    For a single node, the algorithm checks that if there is a left node or a right node, and since there are none, it only copies the single item and exits.

    Therefore, if we can prove that this works for a tree with nodes which are subtrees, we can recursively copy the left and right children.

    Does it copy the left subtree? Since we are using pre-order succession, we will always go to the left first if it exists and then the algorithm starts over.

    Does it copy the right subtree? Since we always add a right subtree before descending to left, we verify that there will be at some point where the preorder successor will be this right child (since we descend left, and we know that we are going to view that left child before we do the right child.)

30) Design an algorithm that threads an unthreaded tree.

    T1. Is $LLINK(P) = \Lambda$? $LTAG(P) \leftarrow 1, LLINK(P) \leftarrow \$P$.


    T2. Is $RLINK(P) = \Lambda$? If so, $RLINK(P) \leftarrow P\$, RTAG(P) \leftarrow 1$.

    T3. Go to P*.

    See [thread.mixal](thread.mixal).  